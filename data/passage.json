{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1699231628989145089",
        "title": "Spring day-02-DI,IoC,AOP",
        "description": null,
        "content": "## DI 注解\n\n## IoC 注解\n\n\n### AOP\n\n增强功能,插入代码逻辑.\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 2,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-09-06T01:22:45.000+00:00",
        "updateTime": "2023-09-06T10:30:55.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 4,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-09-02T13:48:07.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1698805798047686658",
        "title": "java学习之 Spring -day-01",
        "description": "初步认识 Spring",
        "content": "# Spring\n Ioc,DI,Aop.\n\n### Spring体系\n![Spring体系.png](https://pic.code-nav.cn/post_picture/1673111457186713601/vpnZ50hj-Spring体系.png)\n### 开发作用\n\n![Spring在开发中的作用.png](https://pic.code-nav.cn/post_picture/1673111457186713601/NFVO2C2z-Spring在开发中的作用.png)\n\n### \n\n## IOC 思想 (解耦最优)\nIOC是Spring框架的核心思想之一。它指的是将对象的创建和管理交给Spring容器，而不是由开发人员手动创建和管理对象。通过IOC，应用程序的组件之间的依赖关系由容器来管理，这使得代码更加松耦合，可维护性更高。IoC只是一种思想,具体的实现方法是依赖注入.\n| 特性                   | 传统编程方式                                     | 使用IOC的方式                                      |\n|------------------------|-------------------------------------------------|----------------------------------------------------|\n| 对象创建               | 应用程序代码负责手动创建对象                     | 容器负责创建和管理对象                           |\n| 依赖关系管理           | 应用程序代码负责管理对象之间的依赖关系             | 容器负责管理和解决对象之间的依赖关系               |\n| 控制权                 | 应用程序代码控制对象的创建和生命周期               | 控制权交给容器，容器控制对象的创建和生命周期          |\n| 松耦合                 | 通常存在较高的耦合度，因为对象需要直接引用其他对象   | 通过配置和注入，对象之间的耦合度降低                |\n| 可维护性               | 难以维护和修改，因为对象创建和依赖关系散布在应用程序中 | 易于维护和修改，因为依赖关系和配置集中在容器中        |\n| 测试                   | 单元测试通常更加复杂，因为对象需要手动创建和模拟依赖  | 单元测试更容易进行，因为容器可以创建和管理对象，并提供依赖注入 |\n| 扩展性                 | 较差的可扩展性，因为对象之间的耦合度高               | 更好的可扩展性，因为对象之间的耦合度低，可以轻松替换和添加新对象  |\n\n\n\n### Spring 配置文件中的 Bean \n\n#### Bean 的属性\n| 属性/子节点     | 描述                                                         | 示例                                                |\n|----------------|------------------------------------------------------------|----------------------------------------------------|\n| **属性：**     |                                                              |                                                    |\n| `id`           | Bean的唯一标识符。                                           | `<bean id=\"myBean\" ...>`                          |\n| `class`        | 指定要创建的Bean的类的全限定名。                                | `<bean class=\"com.example.MyBeanClass\" ...>`      |\n| `name`         | Bean的名称，可以是一个或多个逗号分隔的值，作为Bean的别名。       | `<bean name=\"bean1,bean2,bean3\" ...>`             |\n| `scope`        | 指定Bean的作用域，可以是 \"singleton\"、\"prototype\"、\"request\"、\"session\" 等。 | `<bean scope=\"singleton\" ...>`                    |\n| `init-method`  | 指定Bean初始化时调用的方法名。                                  | `<bean init-method=\"initMethod\" ...>`             |\n| `destroy-method` | 指定Bean销毁时调用的方法名。                                | `<bean destroy-method=\"destroyMethod\" ...>`       |\n| `value`        | 用于直接设置Bean的基本数据类型属性的值。                         | `<property name=\"propertyName\" value=\"propertyValue\" />` |\n| `ref`          | 用于引用其他Bean，将其注入到当前Bean的属性中，实现依赖注入。        | `<property name=\"dependencyBean\" ref=\"otherBean\" />` |\n| **子节点：**   |                                                              |                                                    |\n| `property`     | 用于进行属性注入，配置Bean的属性值。                           | `<property name=\"propertyName\" value=\"propertyValue\" />` |\n| `constructor-arg` | 用于进行构造函数注入，配置Bean的构造函数参数。                 | `<constructor-arg value=\"argValue\" />`            |\n| `qualifier`    | 用于指定自动装配（autowire）时的Bean限定符，解决依赖注入歧义问题。  | `<qualifier value=\"beanQualifier\" />`             |\n| `lookup-method` | 用于配置方法注入，允许在Bean中查找其他Bean。                   | `<lookup-method name=\"lookupMethodName\" bean=\"targetBean\" />` |\n| `set`          | 用于配置Set类型的属性，可以包含多个值。                        | `<property name=\"setProperty\"><set><value>value1</value><value>value2</value></set></property>` |\n| `list`         | 用于配置List类型的属性，可以包含多个值。                       | `<property name=\"listProperty\"><list><value>value1</value><value>value2</value></list></property>` |\n| `map`          | 用于配置Map类型的属性，可以包含多个键值对。                     | `<property name=\"mapProperty\"><map><entry key=\"key1\" value=\"value1\" /><entry key=\"key2\" value=\"value2\" /></map></property>` |\n\n\n\n#### Bean 的作用域\n在Spring中，Bean的作用域定义了Bean的生命周期和可见性范围。常见的Bean作用域包括：\n\n- Singleton（默认 单例模式）： 每个Spring容器中只有一个Bean实例。每次请求都是同一对象.\n\n- Prototype (多例模式)： 每次请求Bean时都会创建一个新的实例。每次请求都是新对象.\n\n### FactoryBean \nFactoryBean是Spring框架提供的一种特殊的Bean，它用于创建和配置其他Bean的实例。FactoryBean接口允许你自定义Bean的创建逻辑，可以用于复杂的Bean初始化过程。\n\n| 区别                                     | 使用 FactoryBean                                | 不使用 FactoryBean                             |\n|----------------------------------------|------------------------------------------------|-----------------------------------------------|\n| 自定义创建逻辑                           | 可以自定义创建Bean的逻辑，执行自定义初始化操作。   | 使用默认的构造函数创建Bean。                      |\n| 配置灵活性                               | 通过配置方式定义FactoryBean，可以根据配置创建不同类型的Bean。 | 配置相对简单，只需定义Bean的类和属性。               |\n| 懒加载                                   | 默认情况下是懒加载的，只有在第一次请求时才会创建实际的Bean实例。 | 不支持懒加载，Bean在Spring容器启动时立即创建。           |\n| 获取实际Bean实例的方式                  | 需要在Bean名称前加上 `&` 符号，如 `&myFactoryBean`，以获得实际Bean实例。 | 直接使用Bean的名称，无需额外符号。                    |\n\n\n\n## DI 依赖注入\nDI是Spring框架的另一个关键概念，它指的是将一个对象的依赖关系通过外部注入的方式解决，而不是在对象内部硬编码。Spring提供了两种主要的DI方式：\n\n- 设值注入\n\n设值注入是通过setter方法注入依赖关系的方式。通过在Bean的配置中使用<property>元素，你可以指定要注入的依赖。\n\n- 构造器注入\n    \n构造器注入是通过构造函数注入依赖关系的方式。通过在Bean的配置中使用<constructor-arg>元素，你可以指定要传递给构造函数的依赖。\n\n### 各种类型注入\n    \n    \n```\n    注入常量:  <property> 节点中嵌入value属性\n    引用其他Bean组件: <property> 节点嵌入 ref 属性\n    \n```\n\n除了设值注入和构造器注入，Spring还支持各种不同类型的注入，包括：\n\n注解注入： 使用注解（如@Autowired、@Resource等）进行依赖注入。\n    \n接口注入： 实现Spring的特定接口（如ApplicationContextAware、BeanFactoryAware等）以获取依赖。\n    \n基于Java配置的注入： 使用Java类来配置依赖注入。\n    \n属性注入： 使用@Value注解将属性值注入Bean。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1673111457186713601/vn02HcjP-spring-logo.svg",
        "language": null,
        "viewNum": 15,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-09-04T21:10:39.000+00:00",
        "updateTime": "2023-09-06T07:29:28.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 4,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-09-02T13:48:07.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "后端",
          "框架"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1698154399307767809",
        "title": "新人加入",
        "description": "自我介绍",
        "content": "一个刚毕业一年的二本Java后端程序员，分享一下自己工作经历，希望能给大家做为一个参考。 \n大学期间学校教的东西都是落伍的。毕业学期的十月份才注意到社会需求，开始b站疯狂刷视频补课。\n毕业后找公司面试发现其实没那么难，主要还是在基础上，根基越厚越容易过。\n但是还是有些坑爹的公司，比如提高面试难度，故意难为后让你报班的。进去和招人工作不一致的。\n该溜赶紧溜，直接下家\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 8,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1698150412714090498",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-09-03T02:02:13.000+00:00",
        "updateTime": "2023-09-06T03:00:54.000+00:00",
        "user": {
          "id": "1698150412714090498",
          "planetCode": "26426",
          "userName": "Onepunch-Man",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/gibDiao9otOxAeSqMpQCYyzPrD0f77SL4icFn5gq8mWgLh5VJBBeewJwjSdwKcd77MTuoQYiaEhlPmj0qG1Cibpk7kg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 10,
          "coin": 100,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-08-30T09:11:39.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-09-03T01:46:23.000+00:00",
          "updateTime": "2023-09-03T02:02:20.000+00:00"
        },
        "tags": [
          "文章",
          "自我介绍"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1697973869249404929",
        "title": "MyBatis-day-03 和 Maven 构建Java SE 项目",
        "description": "认识 MyBatis 多表查询 1对多 ,多对多",
        "content": "## MyBatis\n### 一对多查询\n 单向多对多之额外 SQL 查询\n根据 id 查询学生，并查询其老师。\n\n需要添加 Mapper 接口 和 Mapper XML\n\nStudentMapper 接口\n\n\n```java\npublic interface StudentMapper { \n\tStudent get(Long id);\n}\n```\n\n\nStudentMapper.xml 文件\n\n```xml\n<resultMap type=\"Student\" id=\"baseResultMap\"> \n\t<id column=\"id\" property=\"id\"/> \n\t<result column=\"name\" property=\"name\"/> \n\t<!-- 关联属性，让 MyBatis 发额外 SQL --> \n\t<collection select=\"cn.wolfcode.mapper.TeacherMapper.queryByStudentId\" column=\"id\" property=\"teachers\"/>\n</resultMap> \n<select id=\"get\" resultMap=\"baseResultMap\">\n\tSELECT id, name FROM student WHERE id = #{id}\n</select>\n```\n\n\nTeacherMapper\n\n```java\npackage xxx.xxx.mapper;\npublic interface queryByStudentId { \n\tTeacher get(Long id); \n        }\n```\n\n\nTeacherMapper.xml 文件\n\n```xml\n<select id=\"queryByStudentId\" resultType=\"Teacher\"> \n\tSELECT t.id, t.name \n\tFROM teacher_student ts \n\tJOIN teacher t ON ts.teacher_id = t.id\n\tWHERE ts.student_id = #{studentId} \n</select>\n```\n\n\n单元测试方法\n\n```java\npublic class Many2oneTest { \n\t@Test \n\tpublic void testGet() throws Exception { \n\t\tSqlSession session = MyBatisUtil.getSession(); \n\t\tStudentMapper studentMapper = session.getMapper(StudentMapper.class); \n\t\tStudent student = studentMapper.get(2L); \n\t\tSystem.out.println(student); session.close(); \n\t}\n}\n```\n\n\n\n### 多对多查询\n多对多映射关系\n什么是多对多关系： 一对多关系就是表A中一条数据对应表B中的多条数据，例如，用户和订单之间的关系，一个用户可以有多个订单信息。\n\n在mybatis中，与一对多映射一致，我们通过resultMap元素的子元素 `collection`来进行处理。\n\n`需要注意的是：在一对多映射和多对多映射中，collection 元素属行中使用的是ofType属性来指定实体对象，而不是使用JavaType属性。`\n\n\n\n#### resultType\n\n作用：将查询结果按照sql列名pojo属性名一致性映射到pojo中。\n场合：常见一些明细记录的展示，比如用户购买商品明细，将关联查询信息全部展示在页面时，此时可直接使用resultType将每一条记录映射到pojo中，在前端页面遍历list（list中是pojo）即可。\nresultMap\n\n使用association和collection完成一对一和一对多高级映射（对结果有特殊的映射要求）。\n\n#### association：\n\n作用：将关联查询信息映射到一个pojo对象中。\n场合：为了方便查询关联信息可以使用association将关联订单信息映射为用户对象的pojo属性中，比如：查询订单及关联用户信息。\n使用resultType无法将查询结果映射到pojo对象的pojo属性中，根据对结果集查询遍历的需要选择使用resultType还是resultMap。\n\n#### collection：\n\n作用：将关联查询信息映射到一个list集合中。\n场合：为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，比如：查询用户权限范围模块及模块下的菜单，可使用collection将模块映射到模块list中，将菜单列表映射到模块对象的菜单list属性中，这样的作的目的也是方便对查询结果集进行遍历查询。如果使用resultType无法将查询结果映射到list集合中。\n\n\n\n\n## Maven \nmaven 导入的jar包具有传递性,会自动导入该jar包需要的其他jar包\n\n### 安装Maven及配置相关文件,环境变量\n\n### 安装\n访问 Maven 的官方网站：https://maven.apache.org/。\n\n下载 Maven 的二进制发行版（Binary zip archive），选择最新版本并下载。\n\n解压下载的二进制发行版到你选择的安装目录，例如 C:\\Program Files\\apache-maven-3.x.x（Windows）或 /usr/local/apache-maven-3.x.x（Linux/Mac）\n\n### 配置环境变量\n\n\n\n3. 右键点击 \"此电脑\"（或 \"计算机\"），然后选择 \"属性\"。\n\n4. 在左侧面板中，点击 \"高级系统设置\"。\n\n6. 在 \"系统属性\" 对话框中，点击 \"环境变量\" 按钮。\n\n8. 在 \"系统变量\" 部分，找到 \"Path\" 变量，然后点击 \"编辑\"。\n\n10. 在 \"编辑环境变量\" 对话框中，点击 \"新建\"，并添加 Maven 的 bin 目录路径，例如 C:\\Program Files\\apache-maven-3.x.x\\bin。\n\n12. 点击 \"确定\" 关闭所有对话框。\n\n### 配置第三方中央仓库\n在maven 安装目录下打开 `settings.xml` 文件。\n\n在` <repositories> `元素中，你可以配置自定义的仓库。\n\n```xml\n\n<repositories>\n  <repository>\n    <id>myrepository</id>\n    <url>http://your-custom-repository-url.com</url>\n  </repository>\n</repositories>\n这里，<id> 是自定义仓库的唯一标识符，<url> 是仓库的地址。你可以添加多个自定义仓库。\n```\n\n保存`settings.xml `文件。\n\n### 在IDEA中使用Maven 构建JAVA SE 项目\n\n1. 打开 IntelliJ IDEA。\n\n3. 创建一个新的 Java 项目或打开现有的项目。\n\n5. 在项目的根目录中，你可以看到一个 pom.xml 文件，这是 Maven 项目的配置文件。确保该文件存在。\n\n7. 打开 IntelliJ IDEA 的项目设置：\n\n9. 在 Windows 上，点击 \"File\" > \"Settings\"。\n\n11. 在左侧面板中，选择 \"Build, Execution, Deployment\"（构建、执行、部署）。\n\n13. 在右侧窗格中，选择 \"Build Tools\"（构建工具）下的 \"Maven\"。\n\n15. 在 \"Maven home directory\"（Maven 安装目录）字段中，选择 Maven 安装的目录，例如 C:\\Program Files\\apache-maven-3.x.x（Windows）或 /usr/local/apache-maven-3.x.x（Linux/Mac）。\n\n17. 点击 \"Apply\" 和 \"OK\" 以保存设置。\n\n19. IntelliJ IDEA 现在将使用 Maven 来构建和管理你的 Java 项目。\n\n21. 你可以在 IntelliJ IDEA 的 Maven 工具窗口中执行 Maven 构建任务，例如 clean, install 等。打开 Maven 工具窗口的方式是点击底部的 \"Maven\" 标签或在 \"View\" > \"Tool Windows\" 中选择 \"Maven\"。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1673111457186713601/PY3E81xY-maven-logo.png",
        "language": null,
        "viewNum": 4,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 1,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-09-02T14:04:51.000+00:00",
        "updateTime": "2023-09-04T23:31:48.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 4,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-09-02T13:48:07.000+00:00"
        },
        "tags": [
          "文章",
          "框架",
          "后端",
          "Java",
          "Java 基础",
          "笔记"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1697971728686358529",
        "title": "JAVA 框架阶段 常见报错信息及解决思路( 持续更新中)",
        "description": "JAVA 框架阶段 常见报错信息及解决思路",
        "content": "# JDBC\n| 错误信息                                     | 可能的原因                                   | 解决方案                                       |\n| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |\n| `java.sql.SQLException: No suitable driver found` | 未加载正确的数据库驱动程序                        | 1. 确保你已经导入了正确的数据库驱动程序库（如MySQL、PostgreSQL等）。 2. 使用 `Class.forName(\"com.mysql.jdbc.Driver\");` 或者 `DriverManager.registerDriver(new com.mysql.jdbc.Driver());` 来注册数据库驱动。 |\n| `java.sql.SQLException: Connection refused`   | 数据库服务器拒绝连接请求                        | 1. 确保数据库服务器正在运行并监听正确的端口。 2. 检查数据库连接字符串中的主机名和端口是否正确。 3. 防火墙或网络问题可能导致连接被拒绝，需要检查网络配置。 |\n| `java.sql.SQLException: Access denied for user` | 用户没有权限连接到数据库                        | 1. 确保用户名和密码正确。 2. 确保数据库用户有访问指定数据库的权限。 3. 检查数据库服务器的访问控制列表（ACL）配置。 |\n| `java.sql.SQLException: Invalid column index`  | 使用了无效的列索引                           | 1. 确保你在查询结果集中使用了正确的列索引。 2. 使用列的名称而不是索引来访问列数据。 |\n| `java.sql.SQLException: ResultSet is closed`  | 尝试访问已关闭的结果集                          | 1. 确保在结果集关闭之前完成了所有操作。 2. 避免在连接关闭后尝试访问结果集。 |\n| `java.sql.SQLException: Duplicate entry`     | 尝试插入重复的数据                            | 1. 在插入之前检查数据是否已经存在。 2. 使用唯一约束来防止重复数据插入。 |\n| `java.sql.SQLException: Timeout expired`     | 操作超时                                     | 1. 增加操作的超时时间。 2. 优化查询或操作以减少执行时间。 |\n\n\n\n# MyBatis\n| 错误信息                                     | 可能的原因                                   | 解决方案                                       |\n| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |\n| `org.apache.ibatis.exceptions.PersistenceException: Error querying database` | SQL查询失败                               | 1. 检查SQL语句是否正确。 2. 检查数据库连接是否正常。 3. 查看数据库日志以获取更多信息。 |\n| `org.apache.ibatis.binding.BindingException: Mapper method 'XXXX' not found` | 找不到Mapper接口中的方法                      | 1. 确保Mapper接口中的方法名称与XML配置文件中的一致。 2. 检查Mapper接口所在的包路径是否正确。 |\n| `org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration` | XML配置文件中存在错误                        | 1. 检查XML配置文件中的语法错误。 2. 确保XML配置文件的路径和名称正确。 |\n| `org.apache.ibatis.executor.ExecutorException: Cannot open Connection` | 无法打开数据库连接                            | 1. 确保数据库服务器正在运行。 2. 检查数据库连接字符串和认证信息是否正确。 3. 检查数据库驱动是否正确配置。 |\n| `org.apache.ibatis.exceptions.TooManyResultsException: Expected one result` | 预期查询返回一条结果，但返回多条结果                   | 1. 修改查询条件以确保只返回一条结果。 2. 使用 `SELECT ... LIMIT 1` 或类似的方法来限制结果数量。 |\n| `org.apache.ibatis.transaction.TransactionException: Transaction is not active` | 事务不活跃                                 | 1. 确保在事务中正确使用 `SqlSession` 对象。 2. 确保事务的提交和回滚操作正确执行。 |\n| `org.apache.ibatis.type.TypeException: Could not resolve type alias` | 类型别名无法解析                             | 1. 检查XML配置文件中的类型别名是否正确。 2. 确保自定义类型处理器注册正确。 |\n| `org.apache.ibatis.parsing.ParsingException: Property 'XXXX' not found in XXXX` | 未找到属性                                | 1. 确保在SQL语句中使用的属性名称存在于对应的Java对象中。 2. 检查属性名称的拼写和大小写。 |\n| `org.apache.ibatis.exceptions.PersistenceException: Error updating database` | 数据库更新操作失败                            | 1. 检查SQL语句是否正确。 2. 确保数据库连接正常。 3. 查看数据库错误日志以获取更多信息。 |\n| `org.apache.ibatis.builder.IncompleteElementException: Could not find a statement` | 找不到指定的 SQL 语句                         | 1. 确保在 XML 配置文件中定义了正确的 SQL 语句。 2. 检查 SQL 语句的命名空间是否正确。 |\n| `org.apache.ibatis.exceptions.PersistenceException: Error deleting database` | 数据库删除操作失败                            | 1. 检查 SQL 语句是否正确。 2. 确保数据库连接正常。 3. 查看数据库错误日志以获取更多信息。 |\n| `org.apache.ibatis.session.SqlSessionException: Error closing session` | 关闭 SqlSession 时出错                         | 1. 确保在使用完 SqlSession 后调用了 `close` 方法。 2. 检查是否有未提交的事务。 |\n| `org.apache.ibatis.executor.ExecutorException: Error updating database` | 数据库更新操作失败                            | 1. 检查 SQL 语句是否正确。 2. 检查数据库连接是否正常。 3. 查看数据库错误日志以获取更多信息。 |\n| `org.apache.ibatis.binding.BindingException: Invalid bound statement` | 无效的绑定语句                               | 1. 检查是否在 XML 配置文件中绑定了正确的语句。 2. 确保语句的命名空间和 ID 正确。 |\n| `org.apache.ibatis.cache.CacheException: Error serializing object` | 对象序列化错误                               | 1. 确保对象及其关联的类都可序列化。 2. 检查对象是否有不可序列化的成员变量。 |\n| `org.apache.ibatis.exceptions.PersistenceException: Error loading class` | 加载类失败                                  | 1. 确保在 XML 配置文件中使用的类路径正确。 2. 检查类是否存在和可访问。 |\n| `org.apache.ibatis.executor.result.ResultMapException: Error attempting to get column 'XXXX' from result set` | 从结果集获取列失败                             | 1. 确保结果集中存在指定的列。 2. 检查映射配置文件中的属性是否正确。 |\n| `org.apache.ibatis.cache.CacheException: Cache 'XXXX' not found` | 缓存未找到                                 | 1. 确保在 XML 配置文件中定义了指定的缓存。 2. 检查缓存名称的拼写和大小写。 |\n| `org.apache.ibatis.builder.IncompleteElementException: Parsing error was found in mapping` | 映射文件中存在解析错误                         | 1. 检查映射文件中的 XML 语法错误。 2. 确保映射文件路径和名称正确。 |\n| `org.apache.ibatis.builder.BuilderException: Error creating document instance` | 创建 XML 文档实例时出错                        | 1. 检查 XML 配置文件的路径和名称是否正确。 2. 确保 XML 文件内容有效。 |\n| `org.apache.ibatis.session.SqlSessionException: Error committing transaction` | 提交事务时出错                               | 1. 确保在事务提交之前没有发生异常。 2. 检查事务管理器的配置是否正确。 |\n| `org.apache.ibatis.reflection.ReflectionException: Could not set property 'XXXX' of 'XXXX' with value 'XXXX'` | 设置属性值时出错                              | 1. 检查属性名称和类型是否正确。 2. 确保属性有对应的 setter 方法。 |\n| `org.apache.ibatis.executor.ExecutorException: Cannot get the result map` | 获取结果映射失败                               | 1. 检查结果映射的名称是否正确。 2. 确保结果映射在 XML 配置文件中定义。 |\n| `org.apache.ibatis.exceptions.PersistenceException: Error updating database.  Cause: java.sql.SQLException: XXXX` | 数据库更新操作失败并引发异常                     | 1. 查看异常的详细信息以获取数据库错误信息。 2. 根据异常信息调整 SQL 语句或数据库配置。 |\n| `org.apache.ibatis.executor.result.ResultMapException: Error attempting to get column 'XXXX' from result set` | 从结果集获取列失败                             | 1. 确保结果集中存在指定的列。 2. 检查映射配置文件中的属性是否正确。 |\n| `org.apache.ibatis.cache.CacheException: Cache 'XXXX' not found` | 缓存未找到                                 | 1. 确保在 XML 配置文件中定义了指定的缓存。 2. 检查缓存名称的拼写和大小写。 |\n| `org.apache.ibatis.builder.IncompleteElementException: Parsing error was found in mapping` | 映射文件中存在解析错误                         | 1. 检查映射文件中的 XML 语法错误。 2. 确保映射文件路径和名称正确。 |\n| `org.apache.ibatis.builder.BuilderException: Error creating document instance` | 创建 XML 文档实例时出错                        | 1. 检查 XML 配置文件的路径和名称是否正确。 2. 确保 XML 文件内容有效。 |\n| `org.apache.ibatis.session.SqlSessionException: Error committing transaction` | 提交事务时出错                               | 1. 确保在事务提交之前没有发生异常。 2. 检查事务管理器的配置是否正确。 |\n| `org.apache.ibatis.reflection.ReflectionException: Could not set property 'XXXX' of 'XXXX' with value 'XXXX'` | 设置属性值时出错                              | 1. 检查属性名称和类型是否正确。 2. 确保属性有对应的 setter 方法。 |\n| `org.apache.ibatis.executor.ExecutorException: Cannot get the result map` | 获取结果映射失败                               | 1. 检查结果映射的名称是否正确。 2. 确保结果映射在 XML 配置文件中定义。 |\n| `org.apache.ibatis.exceptions.PersistenceException: Error updating database.  Cause: java.sql.SQLException: XXXX` | 数据库更新操作失败并引发异常                     | 1. 查看异常的详细信息以获取数据库错误信息。 2. 根据异常信息调整 SQL 语句或数据库配置。 |\n| `org.apache.ibatis.binding.BindingException: Type interface 'XXXX' is not known to the MapperRegistry` | Mapper 接口未被注册                         | 1. 确保 Mapper 接口被正确注册。 2. 检查 Mapper 接口的路径和名称是否正确。 |\n| `org.apache.ibatis.binding.BindingException: Could not find a method` | 未找到 Mapper 接口中的方法                    | 1. 确保 Mapper 接口中存在指定的方法。 2. 检查方法名称和参数是否正确。 |\n\n\n#  Spring",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1673111457186713601/h3F3yiSW-OIP.jpg",
        "language": null,
        "viewNum": 8,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-09-02T13:56:21.000+00:00",
        "updateTime": "2023-09-06T03:42:34.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 4,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-09-02T13:48:07.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "框架",
          "Java 基础",
          "后端"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1697615508439932930",
        "title": "java学习之 MyBatis-day02",
        "description": null,
        "content": "## Mapper组件\n1. 使用Mapper组件\n- 类似DAO，在接口中定义 CRUD 等操作方法。Mapper 组件 =  Mapper 接口 +  Mapper XML 文件。\n- 接口的命名为实体名 + Mapper，一般和其对应 XML 文件放一起\n- XML 命名空间及   **namespace=\"用其对应接口的全限定名\"**\n-  Mapper 接口的方法名要和 Mapper XML 文件元素 一致\n-  方法的返回类型对应 SQL 元素中定义的 resultType / resultMap 类型；\n-  方法的参数类型对应 SQL 元素中定义的 paramterType 类型（一般不写）。\n##### Mapper 接口的原理\n接口是规范，实质做的实现还是要由实现类对象来做，而这个实现类不需要我们写，实现类对象也不由我们创建，这些都 MyBatis 使用动态代理帮我们做了\n提供 Mapper 接口对应 Mapper XML 文件，获取实现类对象的时候传入 Mapper 接口字节码\n## @Param 注解 \n@Param 注解是 MyBatis 中的一个注解，用于指定方法参数的名称。它的主要作用是解决方法参数名称在编译期被丢失的问题，并且可以让你在 XML 映射文件中更加清晰地引用方法参数。\n\n指定方法参数的名称： Java 中，方法参数的名称在编译后会被丢弃，而只保留参数的类型。这意味着在 XML 映射文件中，你无法通过参数名称来引用方法参数。使用 @Param 注解可以为方法参数指定一个名称，这个名称将用于 XML 映射文件中\n\n```java\npublic List<User> findUsers(@Param(\"name\") String name, @Param(\"age\") int age);\n\n```\n当传递一个 List 对象或数组对象参数给 MyBatis 时，MyBatis 会自动把它包装到一个 Map 中，此时：List 对象会以 list 作为 key，数组对象会以 array 作为 key，也可以使用注解 @Param 设置 key 名。\n\n### MyBatis 的 # 和 $\n\n| 特性                 | # 占位符                            | $ 占位符                        |\n|----------------------|-----------------------------------|--------------------------------|\n| 参数替换方式        | 安全替换（预编译）                | 文本替换（不安全）             |\n| 替换参数   | 使用`?`替代参数    | 直接替换参数值       |\n| 替换后的值          | 将参数值作为预编译参数            | 将参数值直接嵌入 SQL 文本       |\n| 防止 SQL 注入攻击    | 是                                | 否                             |\n| 支持表名和列名替换  | 否                                | 是                             |\n| 字符串拼接            | 不需要手动添加单引号             | 需要手动添加单引号              |\n| 适用于参数的数据类型  | 通常适用于所有数据类型             | 主要用于处理字符串和 SQL 片段  |\n| 推荐使用            | 推荐使用 #                         | 慎用 $，容易受到 SQL 注入攻击的风险 |\n| 示例       | `WHERE id = #{id}` | `WHERE id = ${id}`   |\n\n\n\n\n## 动态SQL\n利用动态 SQL 这一特性可以彻底摆脱根据不同条件拼接 SQL 语句的痛苦\n\n- `<where> `标签\n\n`<where>` 标签用于在 SQL 查询中包装多个条件，通常是多个条件之间使用 AND 连接。这个标签会自动处理前置的 WHERE 关键字，并且只在有条件存在时添加 WHERE 关键字。\n\n-`if` 标签\n\n`<if> `标签用于根据条件包含或排除 SQL 查询的一部分。它允许你在运行时检查一个条件，如果条件为真，则包含` <if> `标签内的内容，否则将忽略它。\n\n例如:\n```xml\n<select id=\"selectUsers\" parameterType=\"User\" resultType=\"User\">\n  SELECT * FROM users\n  <where>\n    <if test=\"name != null\">\n      AND name = #{name}\n    </if>\n    <if test=\"age != null\">\n      AND age = #{age}\n    </if>\n  </where>\n</select>\n```\n示例中，< where > 标签包装了两个 < if > 标签，每个 < if > 标签用于检查一个条件是否满足。如果 name 和/或 age 存在，则它们会被包含在 WHERE 子句中，否则 WHERE 子句将为空。\n\n# 多表查询\n\n## 关系应用\n生活中数据很多是存在关系,且存储的数据也能表示出来这种关系\n- 保存：页面的数据      ---> 使用 Java 对象封装 ---> 通过 MyBatis       ---> 数据库表的数据\n- 查询：数据库表的数据  ---> 通过 MyBatis       ---> 封装成 Java 对象   ---> 页面展示数据\n\n### 对象关系分类\n- 泛化关系\n- 实现关系\n- 依赖关系\n- 关联关系\n- 聚合关系\n- 组合关系\n### 关联关系\n\nA 对象依赖 B 对象，并且把 B 作为 A 的一个成员变量，则 A 和 B 存在关联关系。在 UML 中依赖通常使用实线箭头表示。\n\n##### 分类\n\n1. **按照导航性分**\n\n若通过 A 对象中的某一个属性可以访问到 B 对象，则说 A 可以导航到 B。\n\n- 单向：只能从 A 通过属性导航到 B，B 不能导航到 A。\n- 双向：A 可以通过属性导航到 B，B 也可以通过属性导航到 A。\n\n2. **按照多重性分**\n\n- 一对一\n- 一对多\n- 多对一\n- 多对多。\n##### 判断关联关系的分类\n- 判断都是从对象的实例上面来看的；\n- 判断关系需要根据对象的属性；\n- **判断关系必须确定具体需求**。\n\n### 单向多对一之额外 SQL 查询\n单向多对一关系通常用于描述一个实体（多的一端）关联到另一个实体（一的一端）。在MyBatis中，您可以使用额外的SQL查询来检索与多对一关系相关联的数据。\n\n以下是单向多对一关系中使用额外SQL查询的示例：\n\n假设我们有两个实体类：Student 和 Cource ,假设一个学生对应一个课程,即多个学生可能有同一课程。\n\n实体类示例：\n\n```java\n//课程类\n@AllArgsConstructor\n@Getter\n@Setter\n@ToString\n@NoArgsConstructor\npublic class Course {\n    private Long id;\n    private String Name;\n}\n\n//学生类\n@Getter\n@Setter\n@AllArgsConstructor\n@NoArgsConstructor\n@ToString\npublic class Student {\n    private Long id;\n    private String Name;\n    private Integer Age;\n    private Course course;\n}\n```\n映射文件示例：\n\n```xml\n<!--课程查询 -->\n    <resultMap id=\"CourseResultMap\" type=\"Course\">\n        <id property=\"id\" column=\"ID\"/>\n        <result property=\"Name\" column=\"CouName\"/>\n    </resultMap>\n    <select id=\"selectById\" resultMap=\"CourseResultMap\">\n        select * from course where  id=#{id}\n    </select>\n\n<!--学生查询 -->\n<!--  通过查询过程中的id查询 对应的课程信息  -->\n    <resultMap id=\"BaseMap\" type=\"Student\">\n        <id property=\"id\" column=\"id\"/>\n        <result property=\"name\" column=\"StuName\"/>\n        <result property=\"age\" column=\"StuAge\"/>\n        <association property=\"course\" select=\"mybatis.xyz.bycor.mapper.CourseMapper.selectById\"\n                     column=\"Cid\">\n        </association>\n    </resultMap>\n<!--   查询单个学生的信息 (包括课程信息) -->\n    <select id=\"selectById\" resultMap=\"BaseMap\">\n        SELECT * FROM student where id=#{id}\n    </select>\n    <!--  查询所有学生的信息 (包括课程信息) -->\n    <select id=\"selectAll\" resultMap=\"BaseMap\">\n        SELECT * FROM student\n    </select>\n\n <!--  查询所有学生的信息 (包括课程信息)  方式 2-->\n    <resultMap id=\"BaseMap2\" type=\"Student\" >\n        <id column=\"id\" property=\"id\"/>\n        <result column=\"StuName\" property=\"name\"/>\n        <result column=\"StuAge\" property=\"age\"/>\n        <result column=\"CouName\" property=\"course.name\"/>\n        <result column=\"Cid\" property=\"course.id\"/>\n    </resultMap>\n    <select id=\"selectAll2\" resultMap=\"BaseMap2\">\n        select s.id,s.StuName,s.StuAge,c.CouName,c.id Cid\n        from\n            student s\n                join course c on c.id = s.Cid\n    </select>\n\n    <!--  查询所有学生的信息 (包括课程信息)  方式 3-->\n    <resultMap id=\"BaseMap3\" type=\"Student\">\n        <id column=\"id\" property=\"id\"/>\n        <result column=\"StuName\" property=\"name\"/>\n        <result column=\"StuAge\" property=\"age\"/>\n        <association property=\"course\" columnPrefix=\"c_\" javaType=\"Course\">\n            <result column=\"id\" property=\"id\"/>\n            <result column=\"CouName\" property=\"name\"/>\n        </association>\n    </resultMap>\n    <select id=\"selectAll3\" resultMap=\"BaseMap3\">\n        select s.id,s.StuName,s.StuAge,c.CouName c_CouName,c.id c_id\n        from\n            student s\n                join course c on c.id = s.Cid\n    </select>\n```\n\nJava Mapper代码示例：\n\n```java\npublic interface CourseMapper {\n    // 增删 改 查\n    void delete(Long id);\n    void update(Course course);\n    List<Course> selectAll();\n    void insert(Course course);\n    Course selectById(Long id);\n}\n\n\npublic interface StudentMapper {\n    // 增删 改 查\n    void insert(Student student);\n    void delete(Long id);\n    void update(Student student);\n    Student selectById(Long id);\n    List<Student> selectAll();\n    List<Student> selectAll2();\n    List<Student> selectAll3();\n}\n\n```\nJava Test代码示例：\n\n```java\n@Test\n    public void testMany2OneSelect() {\n        // 查询某个的学生信息包括对应的课程信息\n        SqlSession sqlSession = MybatisUtil.getSqlSession();\n        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n        Student student = mapper.selectById(2L);\n        sqlSession.close();\n        System.out.println(student);\n    }\n\n    @Test\n    public void testMany2OneSelectAll() {\n        // 查询所有学生信息包括对应的课程信息\n        SqlSession sqlSession = MybatisUtil.getSqlSession();\n        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n        List<Student> students = mapper.selectAll();\n        sqlSession.close();\n        students.forEach(System.out::println);\n    }\n```\n\n\n在上述示例中，我们定义了一个名为 selectAll~~XXX~~ 的查询操作，它用于获取所有学生的信息，包括他们所选的课程信息。这个查询使用了一个自定义的结果映射 BaseMap3，将学生的属性和相关的课程信息进行关联。\n\n下面是这个查询的要点总结：\n\n查询操作：selectAll3，用于获取所有学生的信息以及他们所选的课程信息。\n\n结果映射：BaseMap3，自定义结果映射，用于将查询结果映射到 Student 类型的对象上。\n\n查询语句：SQL 查询语句联接了 student 表和 course 表，通过学生表的外键关联了相关的课程信息。\n\n结果映射配置：在结果映射中，我们定义了学生属性的映射，以及关联的课程属性的映射。这样，查询结果将自动映射到 Student 对象的属性中，包括学生的基本信息和所选课程的信息。\n\n通过这种方式，我们可以一次性获取学生和他们所选课程的信息，无需手动处理查询结果集的关联，提高了代码的可读性和查询效率。这是 MyBatis 中处理多表关联查询的一种常见方法。\n\n\n\n\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1673111457186713601/qggzrwYj-8IBi0oc9-mybatis-logo.png",
        "language": null,
        "viewNum": 6,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-09-01T14:20:52.000+00:00",
        "updateTime": "2023-09-04T03:26:53.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 4,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-09-02T13:48:07.000+00:00"
        },
        "tags": [
          "后端",
          "Java",
          "Java 基础",
          "学习路线",
          "笔记",
          "框架",
          "数据库",
          "文章"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1696843331792904193",
        "title": "java学习之 MyBatis-day01",
        "description": "初步认识 MyBatis",
        "content": "# 初识框架\n**框架是一种经过校验、具有一定功能的半成品软件**.\n\n- **经过校验**：指框架本身经过测试，且框架自身所具有的功能已经实现\n\n- **具有一定功能**：指框架可以完成特定的功能，不同的框架功能不同\n\n- **半成品软件**：指框架自身是一个软件，但是该软件无法直接运行，需要配合其他的程序才可以完成指定的工作.\n### 程序架构\n一.分层\n\n![三层架构.png](https://pic.code-nav.cn/post_picture/1673111457186713601/DHmK4tQ0-三层架构.png)\n\n二.架构分工\n\n![image.png](https://pic.code-nav.cn/post_picture/1673111457186713601/hdTMx1fM-image.png)\n\n三.架构职责\n\n![三层架构职责.png](https://pic.code-nav.cn/post_picture/1673111457186713601/ouLtMzB8-三层架构职责.png)\n\n# MyBatis 基础\nMyBatis 是一款优秀的**持久层框架**，它支持定制化 SQL、存储过程以及高级映射。**MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集**。\n\n## 使用流程\n\n![image-20200530114424946.png](https://pic.code-nav.cn/post_picture/1673111457186713601/TCQxe3T1-image-20200530114424946.png)\n\n## 准备环境\n\n`添加项目需要的 jar 包`\n\n1. lombok-1.18.20.jar\n\n   Lombok,自动生成 getter/setter/toString 等方法\n\n   使用的前提是已经在 idea 中安装了 lombok 插件\n\n2. mysql-connector-java-5.1.26-bin.jar\n\n   MySQL 数据库的 JDBC 驱动包,访问 MySQL 必须导入备 jar 包\n\n3. mybatis-3.4.5.jar\n\n   MyBatis 框架的核心 jar 包\n   \n4. 创建操作的表\n5. 根据表结构创建实体类\n\n4. **mybatis 主配置文件:  mybatis-config.xml**\n\n1. 在项目的 resources(resources root)下创建 mybatis-config.xml 配置文件\n\n6. 拷贝 xml 的约束\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n   <!DOCTYPE configuration\n     PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n     \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n   ```\n\n7. 添加环境配置(事务管理器 / 连接池 /  映射文件)\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n      <!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n      <configuration>\n        <environments default=\"dev\">\n          <environment id=\"dev\">\n            <!--\n      \t\tMyBatis 内置的事务管理器\n      \t\tJDBC:org.apache.ibatis.transaction.jdbc.JdbcTransaction的别名\n      \t  -->\n            <transactionManager type=\"JDBC\"/>\n            <!--\n      \t\tMyBatis 内置的连接池\n      \t\tPOOLED:org.apache.ibatis.datasource.pooled.PooledDataSource的别名\n      \t  -->\n            <dataSource type=\"POOLED\">\n              <!-- \n       \t\t\tdriver:这是POOLED连接池对象的驱动类的属性名,\n      \t\t\tDruid连接池对象的驱动类属性名是driverClassName\n      \t\t-->\n              <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n              <property name=\"url\" value=\"jdbc:mysql:///mybatis\"/>\n              <property name=\"username\" value=\"root\"/>\n              <property name=\"password\" value=\"admin\"/>\n            </dataSource>\n          </environment>\n        </environments>\n        <mappers>\n          <mapper resource=\"xxx/mapper/UserMapper.xml\"/>\n        </mappers>\n      </configuration>\n   ```\n\n8. db.properties配置文件\n\n   在主配置文件中配置的内容较多, 其中包括我们修改频率较高的数据库连接信息(driver/url/username/password)等,我们可以在修改这些信息的过程中误改或者误删到其他的配置,为了解决这个问题,我们仍然是将这些信息配置到db.propertie 配置文件中,然后再合并到主配置文件即可,如下:\n\n   ```properties\n   driverClassName=com.mysql.jdbc.Driver\n   url=jdbc:mysql://localhost:3306/mybatis\n   username=root\n   password=admin\n   ```\n\n   mybatis-config.xml\n\n   ```xml\n   <configuration>\n   \t<!-- 关联db.properties:为了把连接数据库的信息单独放到一个配置文件 -->\n   \t<properties resource=\"db.properties\" />\n   </configuration>\n   ```\n   9. mapper 映射文件: UserMapper.xml\n\n   mybatis中,访问数据库的SQL语句是编写在mapper配置文件中的,程序员按照这个文件约定的格式进行配置即可在包 cn.wolfcode.day09.mapper 中创建配置文件: UserMapper.xml\n\n   拷贝下面的约束信息到配置文件中\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n      <!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n   ```\n\n   在配置文件中添加 SQL 语句\n\n   ```xml\n   <!--\n   \t一个项目可以操作多张表\n   \t每张表都需要一个mapper配置文件来编写SQL语句\n   \t每条SQL语句都需要有一个唯一的标识\n   \t这个唯一的标识由 namespace + sqlid 组成\n   \t使用下面的namespace+sqlid就得到了保存用户信息的唯一标识:\n   \tcn.wolfcode.mybatis.mapper.UserMapper.insert\n   \t接下来,我们就可以使用上面的标识找到这条SQL语句了\n   -->\n   <mapper namespace=\"cn.wolfcode.mybatis.mapper.UserMapper\">\n     <insert id=\"insert\">\n       insert into user(name,age,salary,hiredate) \n       values(#{name}, #{age}, #{salary}, #{hiredate})\n     </insert>\n   </mapper>\n   ```\n\n\n\n**注意**: 一定记得在 mybatis-config.xml 配置文件中关联映射文件\n\n   ```xml\n   <mappers>\n       <!--\n   \t\t这里是mapper文件的路径,所以使用/分割\n   \t-->\n       <mapper resource=\"xxx/mybatis/mapper/UserMapper.xml\"/>\n   </mappers>\n   ```\n\n## 2.4_MyBatis 执行流程(理解)\n\n1. 加载主配置文件 (mybatis-config.xml & XxxMapper.xml) 到内存中,将数据封装成对象\n   \tConfiguration/Environment/TransactionManager/DataSource/Statement Collection等\n\n\n2. 通过操作拿到访问数据库的基本信息,根据这些数据创建 SqlSessionFactory 对象\n   \n3. 从 SqlSessionFactory 对象中获取到 SqlSession 对象,然后执行SQL\n   \n4. INSERT INTO user(name,age,salary) \n     \t\tVALUES(#{name},#{age},#{salary})\n\n   被翻译成\n\n   INSERT INTO user(name,age,salary) \n     \t\tVALUES(?, ?, ?)\n\n5. 使用 PreparedStatement 来执行指定的SQL\n\n   从传递进来的 User 对象中依次获取到 name/age/salary 这些属性的值\n\n   这里需要使用到内省机制来访问对象中的属性\n\n**注:**\n\n在加载完当前映射文件之后,会将SQL中的 #{} **OGNL表达式**翻译成对应的占位符?\n# 3_获取自动生成的主键\n\n在开发中,如果需要获取到数据库中自动生成的主键,那么使用 MyBatis 应该如何实现呢?\n\n```xml\n<insert id=\"insert\" useGeneratedKeys=\"true\" keyProperty=\"id\" keyColumn=\"id\">\n    insert into user(name,age,salary,hiredate) \n    values(#{name}, #{age}, #{salary}, #{hiredate})\n</insert>\n```\n\nuseGeneratedKeys: 是否要获取自动生成的主键\n\nkeyColumn: 表中的主键列\n\nkeyProperty: 主键列对应的属性  表示从获取哪个列的值封装到哪个属性中\n\n\n# 4_日志管理 （掌握）\n\n在持久层的开发过程中,我们程序员需要随时观察SQL的执行情况,如果sql有问题,我们能够及时发现\n所以,如果能够在控制台中将我们执行的 SQL 全部打印出来,那么就可以方便的观察SQL的相关问题\n\n配置日志文件监控 MyBatis 的运行.\n\n1. 将日志相关的 jar 包添加到项目中\n\n\n![image-20200427083931199.png](https://pic.code-nav.cn/post_picture/1673111457186713601/qN3EneWV-image-20200427083931199.png)\n\n2. 在 resources(resources root)中创建配置文件, log4j.properties ,添加下面的内容(直接拷贝)\n\n   ```properties\n   # Global logging configuration\n   log4j.rootLogger=ERROR, stdout\n   # 配置要打印日志的包\n   log4j.logger.xxx=TRACE\n   # Console output...\n   log4j.appender.stdout=org.apache.log4j.ConsoleAppender\n   log4j.appender.stdout.layout=org.apache.log4j.PatternLayout\n   log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n\n   ```\n\n3. 将配置中的 包路径修改为项目中对应的路径,我们这里可以使用: cn.wolfcode.mybatis\n\n到此,我们每执行一条 SQL, 都会在控制台中打印出来,这非常有助于我们对 SQL 的分析,特别是 SQL 不正确的时候\n\n\n# 7_类型别名\n\n在查询操作中, 我们需要使用 resultType 属性指定数据封装的类型, 这里的值是类型的全限定名, 每次都写的话比较麻烦,为了简化这里的配置,我们可以在主配置文件(mybatis-config.xml)中对指定的类型做别名的配置\n\n```xml\n<!-- 为指定包中的类来生成别名,默认是类的简单名称 -->\n<typeAliases>\n    <package name=\"包名\"/>\n</typeAliases>\n```\n\n如此,我们在查询的SQL中, 使用类的全限定名和使用别名是等价的\n\n修改前:\n\n```xml\n<select id=\"selectAll\" resultType=\"XXX.domain.User\">\n\tselect * from user\n</select>\n```\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1673111457186713601/8IBi0oc9-mybatis-logo.png",
        "language": null,
        "viewNum": 16,
        "thumbNum": 3,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-08-30T11:12:30.000+00:00",
        "updateTime": "2023-09-02T14:05:17.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 4,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-09-02T13:48:07.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "Java 基础",
          "框架",
          "学习路线",
          "笔记",
          "后端"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1696541049670967298",
        "title": "Jdbc-day-02",
        "description": "事务，连接池，sql注入",
        "content": "1. **jdbc事务操作**\n   1. 事务介绍：\n> 事务就是 数据从一种状态到另一种状态的过程，通常将多个SQL语句的执行划分到一个事务中。\n\n   2. **事务作用（ACID）**\n      1. **原子性**：确保事务中的操作，要么都发生，要么都不发生\n      2. **一致性**：确保在事务操作后，数据的变化总和不变\n      3. **隔离性**：确保事务于事务之前互不干扰\n      4. **持久性**：确保事务一旦提交，就不能更改，如果需要更改，就必须开启新的事务\n   3. 事务操作逻辑，流程：\n:::tips\n\n1. **setAutoCommit(boolean autoCommit)**: 设置事务的自动提交模式。当设置为true时，每个SQL语句都会自动提交事务；当设置为false时，需要手动调用commit()方法提交事务。\n2. **commit():** 提交事务。将之前所有已执行的SQL语句的结果永久保存到数据库中。\n3. **rollback(): **回滚事务。取消之前所有已执行的SQL语句，恢复到事务开始之前的状态。\n:::\n\n   4. 操作模板\n```java\ntry{\n    //取消事务自动提交机制,设置为手动提交 \n\tconnection对象.setAutoCommit(false);\n    //操作1\n    //操作2\n    //异常\n    //操作3\n    //....\n    //所有操作成功则 手动提交事务                          \n    connection对象.commit();\n}catch(Exception e){\n  \t//处理异常\n    \n   \t//出现异常 回滚事务\n\tconnection对象.rollback();\n}\n```\n\n   5. 实现：\n```java\npublic void testTransfer() throws SQLException {\n\tConnection conn = JDBCUtil.getConnection();\n\tPreparedStatement ps = null;\n\tResultSet re = null;\n\n\ttry{\n        //(1).开启事务自动提交的模式\n    \tconn.setAutoCommit(false);//false为不自动提交\n    \t\n        //查询是否够\n    \tps = conn.prepareStatement(\"select * from account \n                                   where name=? and balance >=?\");\n    \tps.setString(1,\"凯哥\");\n    \tps.setBigDecimal(2,new BigDecimal(\"1000\"));\n    \tre = ps.executeQuery();\n    \tif(!re.next()){\n        \tSystem.out.println(\"余额不足\");\n        \treturn;\n    \t}\n\n    // 减少1000\n    \tps=conn.prepareStatement(\"update account set \n                                 balance = balance -? where name = ?\");\n    \tps.setBigDecimal(1,new BigDecimal(\"1000\"));\n    \tps.setString(2,\"凯哥\");\n    \tps.executeUpdate();\n\t// 增加1000 \n    \tps=conn.prepareStatement(\"update account set balance = \n                                 balance +? where name=?\");\n    \tps.setBigDecimal(1,new BigDecimal(\"1000\"));\n    \tps.setString(2,\"赵云\");\n    \tps.executeUpdate();\n\n        //如果上面的SQL执行没有出错，便手动提交，原子性\n    \tconn.commit();\n        //提交后不能回滚，持久性\n\n\t}catch(Exception e){\n    \te.printStackTrace();\n\n        //如果出现异常，就回滚到最初的状态，都不执行提交\n    \tconn.rollback();//一致性，原子性\n\n\t}finally {\n        JDBCUtil.coles(re,ps,conn);\n\t}\n}\n```\n> **注意：**\n> 1. 默认情况下,事务在执行完 DML 操作就自动提交.\n> 2. 数据库的事务支持：不是所有的数据库都支持事务操作，需要确保所使用的数据库支持事务。\n> 3. Connection对象的事务隔离级别：在创建Connection对象时，可以设置事务的隔离级别\n> 4. 异常处理：在执行SQL语句时，可能会发生异常，需要根据具体情况进行异常处理，如回滚事务或提交事务。\n\n2. **jdbc连接池操作**\n   1. 连接池介绍：\n:::success\n连接池是数据库的缓冲池，预先在池中放入一定量的连接，在程序需要使用时，从池中取出，不用时又还回到池中。\n连接池在Java中只提供了一个接口，池的操作由第三方提供\n:::\n\n   2. 连接池作用：\n      1. **提高性能**：避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间\n      2. **统一连接管理**：避免数据库连接泄漏在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露\n   3. 连接池逻辑：\n:::tips\n\n1. 拷贝 druid-1.0.15.jar 到项目\n2. 配置 db.properties 书写连接需要的属性\n3. 连接池对象获取：DruidDataSourceFactory.createDataSource(p);\n4. 连接对象获取：dataSource对象.getConnection();\n5. 归还连接对象: Connection对象.close();\n:::\n\n   4. 实现：\n```java\nprivate static DataSource ds;//连接池对象\n\nstatic {\n    try {\n        //文件对象\n        Properties properties = new Properties();\n        //解析文件，封装数据到pro对象中\n        properties.load(Thread.currentThread().getContextClassLoader().getResourceAsStream(\"db.properties\"));\n\n        // 通过连接池获取连接池对象\n        ds = new DruidDataSourceFactory().createDataSource(properties);\n\n        Class.forName(properties.getProperty(\"driverClassName\"));\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\n//通过连接池获取conn对象\npublic static Connection getConnection(){\n    try {\n        return ds.getConnection();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n\n3. **SQL注入（了解）**\n   1. 原理：\n程序采用了拼接型的SQL语句，用户可以输入带有特殊字符的语句改变SQL的结构，获取到数据库的信息\n   2. 防范\n> 采用预编译型的SQL语句，通过占位符，会将带特殊的字符语句固定为字符串，防止SQL语句结构的改变",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 7,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-08-29T15:11:21.000+00:00",
        "updateTime": "2023-08-31T14:47:06.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 4,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-09-02T13:48:07.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "155",
    "size": "10",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "16"
  },
  "message": "ok"
}